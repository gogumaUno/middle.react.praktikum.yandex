{"version":3,"sources":["logo.svg","models/enums/MessageTypes.ts","models/constants/resources.ts","shared/Avatar/Avatar.tsx","components/Chat/Card/Meta/ChatCardMeta.tsx","components/Chat/Card/Message/ChatCardMessage.tsx","helpers/dateHelper.ts","components/Chat/Card/ChatCard.tsx","components/Chat/List/ChatList.tsx","components/Main/Sidebar/MainSidebar.tsx","components/Chat/MessageWrapper/ChatMessageWrapper.tsx","components/Chat/ServiceMessage/ChatServiceMessage.tsx","components/Chat/TextMessage/ChatTextMessage.tsx","components/Chat/History/ChatHistory.tsx","components/Main/Content/MainContent.tsx","helpers/MockState/mockStateHelpers.ts","helpers/MockState/mockStateFactories.ts","helpers/MockState/MockStateStorage.ts","helpers/MockState/MockService.ts","helpers/sortHelper.ts","helpers/utils.ts","components/Main/Layout/MainLayout.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","MessageTypes","resources","chat","avatar","cardIcon","messageAuthor","default","messages","serviceMessage","messageWrap","Avatar","className","src","alt","ChatCardMeta","chatName","lastMessageDate","ChatCardMessage","author","message","formatUnit","n","dateHelper","getDate","d","date","Date","day","month","getMonth","year","getFullYear","getTime","hours","getHours","minutes","getMinutes","seconds","getSeconds","removeTimeFromTimestamp","setHours","getServiceMessage","toDateString","ChatCard","guid","logo","name","lastMessage","isSelected","onChatSelected","messageDate","timestamp","onClick","type","content","ChatList","chatList","selectedChat","map","item","key","MainSidebar","ChatMessageWrapper","children","ChatServiceMessage","ChatTextMessage","style","position","ChatHistory","messageList","Service","Text","MainContent","onChatClosed","randomInteger","max","rand","Math","random","floor","storageAssembler","keys","factory","reduce","acc","i","messagesFactoryWrapper","users","contentStorage","authorIds","start","end","messagesNumber","length","uuid","authorId","push","messagesFactory","MockStateStorage","userStorage","chatStorage","messageStorage","initialized","chatNames","usernames","this","initializeStorage","index","userFactoryWrapper","chatInfoFactoryWrapper","Object","id","Promise","resolve","init","mockService","storage","checkIfInitialized","chats","getChats","getMessages","chatInfo","mapToChatInfo","chatId","history","getChatHistoryByChatId","mapToMessage","m","getUserById","chatMessages","sortHelper","sortByDate","a","b","utils","addServiceMessageToChatHistory","dateSet","Set","has","add","MainLayout","props","setState","loadChatHistory","state","chatHistory","getChatList","sort","then","getSortedChatList","getMessageList","Component","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","console"],"mappings":"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","file":"static/js/main.36d1ff66.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","export enum MessageTypes {\r\n  Service,\r\n  Text,\r\n}\r\n","const resources = {\r\n  chat: {\r\n    avatar: {\r\n      cardIcon: 'Chat icon',\r\n      messageAuthor: 'Author avatar',\r\n      default: 'Avatar',\r\n    },\r\n    messages: {\r\n      serviceMessage: 'service-message',\r\n      messageWrap: 'message-wrap',\r\n    },\r\n  },\r\n};\r\n\r\nexport default resources;\r\n","import React, { FunctionComponent } from 'react';\r\n\r\nimport { AvatarProps } from './AvatarProps';\r\n\r\nimport resources from '../../models/constants/resources';\r\n\r\nimport './Avatar.css';\r\n\r\nexport const Avatar: FunctionComponent<AvatarProps> = ({\r\n  className,\r\n  src,\r\n  alt = resources.chat.avatar.default,\r\n}: AvatarProps) => (\r\n  <div className={className}>\r\n    <img src={src} alt={alt} />\r\n  </div>\r\n);\r\n","import React, { FunctionComponent } from 'react';\r\n\r\nimport { IChatCardMetaProps } from './IChatCardMetaProps';\r\n\r\nimport './ChatCardMeta.css';\r\n\r\nexport const ChatCardMeta: FunctionComponent<IChatCardMetaProps> = ({ chatName, lastMessageDate }: IChatCardMetaProps) => (\r\n  <div className=\"card-meta\">\r\n    <div className=\"card-meta__name\">\r\n      <span>{chatName}</span>\r\n    </div>\r\n    <div className=\"card-meta__date\">\r\n      <span>{lastMessageDate}</span>\r\n    </div>\r\n  </div>\r\n);\r\n","import React, { FunctionComponent } from 'react';\r\n\r\nimport { IChatCardMessageProps } from './IChatCardMessageProps';\r\n\r\nimport './ChatCardMessage.css';\r\n\r\nexport const ChatCardMessage: FunctionComponent<IChatCardMessageProps> = ({ author, message }: IChatCardMessageProps) => (\r\n  <div className=\"card-message\">\r\n    <span className=\"card-message__author\">\r\n      {author}\r\n      :\r\n    </span>\r\n    <span className=\"card-message__content\">{message}</span>\r\n  </div>\r\n);\r\n","const formatUnit = (n: number) => {\r\n  return n >= 10 ? n : `0${n}`;\r\n};\r\n\r\nconst getDate = (d: Date | number) => {\r\n  const date = new Date(d);\r\n  const day = formatUnit(date.getDate());\r\n  const month = formatUnit(date.getMonth() + 1);\r\n  const year = formatUnit(date.getFullYear());\r\n  return `${day}/${month}/${year}`;\r\n};\r\n\r\nconst getTime = (d: Date | number) => {\r\n  const date = new Date(d);\r\n  const hours = formatUnit(date.getHours());\r\n  const minutes = formatUnit(date.getMinutes());\r\n  const seconds = formatUnit(date.getSeconds());\r\n  return `${hours}:${minutes}:${seconds}`;\r\n};\r\n\r\nconst removeTimeFromTimestamp = (d: number | Date) => {\r\n  const date = new Date(d);\r\n  return date.setHours(0, 0, 0, 0);\r\n};\r\n\r\nconst getServiceMessage = (d: number | Date) => {\r\n  const date = new Date(d);\r\n  return date.toDateString();\r\n};\r\n\r\nconst dateHelper = {\r\n  getDate,\r\n  getTime,\r\n  removeTimeFromTimestamp,\r\n  getServiceMessage,\r\n};\r\n\r\nexport default dateHelper;\r\n","import React, { FunctionComponent } from 'react';\r\n\r\nimport { Avatar } from '../../../shared/Avatar/Avatar';\r\n\r\nimport { IChatCardProps } from './IChatCardProps';\r\nimport { ChatCardMeta } from './Meta/ChatCardMeta';\r\nimport { ChatCardMessage } from './Message/ChatCardMessage';\r\n\r\nimport dateHelper from '../../../helpers/dateHelper';\r\nimport resources from '../../../models/constants/resources';\r\n\r\nimport './ChatCard.css';\r\n\r\nexport const ChatCard: FunctionComponent<IChatCardProps> = ({\r\n  guid,\r\n  logo,\r\n  name,\r\n  lastMessage,\r\n  isSelected,\r\n  onChatSelected,\r\n}: IChatCardProps) => {\r\n  const messageDate = dateHelper.getDate(lastMessage.timestamp);\r\n  return (\r\n    <button className=\"card-wrap button-reset\" onClick={() => onChatSelected(guid)} type=\"button\">\r\n      <section className={`card ${isSelected ? 'selected' : ''}`}>\r\n        <section className=\"card__body\">\r\n          <Avatar className=\"card__logo\" src={logo} alt={resources.chat.avatar.cardIcon} />\r\n          <section className=\"card__info\">\r\n            <ChatCardMeta chatName={name} lastMessageDate={messageDate} />\r\n            <ChatCardMessage author={lastMessage.author.name} message={lastMessage.content} />\r\n          </section>\r\n        </section>\r\n      </section>\r\n    </button>\r\n  );\r\n};\r\n","import React, { FunctionComponent } from 'react';\r\n\r\nimport { ChatCard } from '../Card/ChatCard';\r\n\r\nimport { IChatListProps } from './IChatListProps';\r\n\r\nexport const ChatList: FunctionComponent<IChatListProps> = ({ chatList, selectedChat, onChatSelected }: IChatListProps) => (\r\n  <section>\r\n    {chatList.map((item) => {\r\n      const isSelected = selectedChat === item.guid;\r\n      return (\r\n        <ChatCard {...item} isSelected={isSelected} onChatSelected={onChatSelected} key={item.guid} />\r\n      );\r\n    })}\r\n  </section>\r\n);\r\n","import React, { FunctionComponent } from 'react';\r\n\r\nimport { IMainSidebarProps } from './IMainSidebarProps';\r\n\r\nimport { ChatList } from '../../Chat/List/ChatList';\r\n\r\nimport './MainSidebar.css';\r\n\r\nexport const MainSidebar: FunctionComponent<IMainSidebarProps> = ({\r\n  onChatSelected,\r\n  selectedChat,\r\n  className,\r\n  chatList,\r\n}: IMainSidebarProps) => (\r\n  <aside className={`sidebar ${className}`}>\r\n    <ChatList onChatSelected={onChatSelected} selectedChat={selectedChat} chatList={chatList} />\r\n  </aside>\r\n);\r\n","import React, { FunctionComponent } from 'react';\r\n\r\nimport { IChatMessageWrapperProps } from './IChatMessageWrapperProps';\r\n\r\nimport resources from '../../../models/constants/resources';\r\n\r\nimport './ChatMessageWrapper.css';\r\n\r\nexport const ChatMessageWrapper: FunctionComponent<IChatMessageWrapperProps> = ({\r\n  className = resources.chat.messages.messageWrap,\r\n  children,\r\n}: IChatMessageWrapperProps) => (\r\n  <div>\r\n    <div className={className}>\r\n      {children}\r\n    </div>\r\n  </div>\r\n);\r\n","import React, { FunctionComponent } from 'react';\r\n\r\nimport { ChatMessageWrapper } from '../MessageWrapper/ChatMessageWrapper';\r\n\r\nimport { IServiceMessage } from '../../../models/interfaces/IMessage';\r\n\r\nimport dateHelper from '../../../helpers/dateHelper';\r\nimport resources from '../../../models/constants/resources';\r\n\r\nimport './ChatServiceMessage.css';\r\n\r\nexport const ChatServiceMessage: FunctionComponent<IServiceMessage> = ({ timestamp }: IServiceMessage) => (\r\n  <ChatMessageWrapper className={resources.chat.messages.serviceMessage}>\r\n    <span className=\"service-message__date\">{dateHelper.getServiceMessage(timestamp)}</span>\r\n  </ChatMessageWrapper>\r\n);\r\n","import React, { FunctionComponent } from 'react';\r\n\r\nimport { Avatar } from '../../../shared/Avatar/Avatar';\r\nimport { ChatMessageWrapper } from '../MessageWrapper/ChatMessageWrapper';\r\n\r\nimport { ITextMessage } from '../../../models/interfaces/IMessage';\r\n\r\nimport resources from '../../../models/constants/resources';\r\nimport dateHelper from '../../../helpers/dateHelper';\r\n\r\nimport './ChatTextMessage.css';\r\n\r\nexport const ChatTextMessage: FunctionComponent<ITextMessage> = ({\r\n  author,\r\n  content,\r\n  timestamp,\r\n}: ITextMessage) => (\r\n  <ChatMessageWrapper>\r\n    <section style={{ position: 'relative' }} className=\"message\">\r\n      <Avatar className=\"message__icon\" src={author.avatar} alt={resources.chat.avatar.messageAuthor} />\r\n      <div className=\"message__body\">\r\n        <span className=\"message__author\">{author.name}</span>\r\n        <div className=\"message__content\">\r\n          <span>{content}</span>\r\n        </div>\r\n      </div>\r\n      <div className=\"message__time\">\r\n        <span>{dateHelper.getTime(timestamp)}</span>\r\n      </div>\r\n    </section>\r\n  </ChatMessageWrapper>\r\n);\r\n","import React, { FunctionComponent } from 'react';\r\n\r\nimport { ChatServiceMessage } from '../ServiceMessage/ChatServiceMessage';\r\nimport { ChatTextMessage } from '../TextMessage/ChatTextMessage';\r\n\r\nimport { IChatHistoryProps } from './IChatHistoryProps';\r\nimport { MessageTypes } from '../../../models/enums/MessageTypes';\r\n\r\nimport './ChatHistory.css';\r\n\r\nexport const ChatHistory: FunctionComponent<IChatHistoryProps> = ({ messageList }: IChatHistoryProps) => (\r\n  <div className=\"message-history\">\r\n    {messageList.map((message) => {\r\n      switch (message.type) {\r\n        case MessageTypes.Service:\r\n          return <ChatServiceMessage key={message.guid} {...message} />;\r\n        case MessageTypes.Text:\r\n        default:\r\n          return <ChatTextMessage key={message.guid} {...message} />;\r\n      }\r\n    })}\r\n  </div>\r\n);\r\n","import React, { FunctionComponent } from 'react';\r\n\r\nimport { ChatHistory } from '../../Chat/History/ChatHistory';\r\n\r\nimport { IMainContentProps } from './IMainContentProps';\r\n\r\nimport './MainContent.css';\r\n\r\nexport const MainContent: FunctionComponent<IMainContentProps> = ({\r\n  onChatClosed,\r\n  messageList,\r\n  className,\r\n}: IMainContentProps) => (\r\n  <div className={`content ${className}`}>\r\n    <button className=\"close-chat-button button-reset\" onClick={onChatClosed} type=\"button\">X</button>\r\n    <ChatHistory messageList={messageList} />\r\n  </div>\r\n);\r\n","export function randomInteger(max: number) {\r\n  const rand = 1 + Math.random() * (max);\r\n  return Math.floor(rand);\r\n}\r\n\r\nexport function randomDate(start: Date, end: Date) {\r\n  return new Date(start.getTime() + Math.random() * (end.getTime() - start.getTime())).getTime();\r\n}\r\n","import { v4 as uuid } from 'uuid';\r\n\r\nimport { IMockMessage } from './interfaces/IMockMessage';\r\nimport { MessageTypes } from '../../models/enums/MessageTypes';\r\nimport { IHashTable } from '../../models/interfaces/IHashTable';\r\n\r\nimport { randomInteger, randomDate } from './mockStateHelpers';\r\n\r\nimport logo from '../../logo.svg';\r\n\r\nexport function messagesFactory(contentStorage: string[], authorIds: string[]): IMockMessage[] {\r\n  const messagesNumber = randomInteger(contentStorage.length - 1);\r\n  const messages: IMockMessage[] = [];\r\n  for (let i = 0; i <= messagesNumber; i += 1) {\r\n    const guid = uuid();\r\n    const authorId = authorIds[randomInteger(authorIds.length - 1)];\r\n    const content = contentStorage[randomInteger(contentStorage.length - 1)];\r\n    const timestamp = randomDate(new Date(2020, 0, 1), new Date());\r\n    messages.push({\r\n      guid,\r\n      authorId,\r\n      content,\r\n      timestamp,\r\n      type: MessageTypes.Text,\r\n    });\r\n  }\r\n  return messages;\r\n}\r\n\r\nexport function storageAssembler<T>(keys: string[], factory: (k: string, i: number) => T): IHashTable<T> {\r\n  return keys.reduce((acc: IHashTable<T>, key, i) => {\r\n    acc[key] = factory(key, i);\r\n    return acc;\r\n  }, {});\r\n}\r\n\r\nexport function userFactoryWrapper(usernames: string[]) {\r\n  return (guid: string, index: number) => ({\r\n    guid,\r\n    name: usernames[index],\r\n    avatar: logo,\r\n  });\r\n}\r\n\r\nexport function chatInfoFactoryWrapper(chatNames: string[]) {\r\n  return (guid: string, index: number) => ({\r\n    guid,\r\n    name: chatNames[index],\r\n    logo,\r\n  });\r\n}\r\n\r\nexport function messagesFactoryWrapper(messages: string[], users: string[]) {\r\n  return () => messagesFactory(messages, users);\r\n}\r\n","import { v4 as uuid } from 'uuid';\r\n\r\nimport { IHashTable } from '../../models/interfaces/IHashTable';\r\n\r\nimport {\r\n  storageAssembler,\r\n  userFactoryWrapper,\r\n  chatInfoFactoryWrapper,\r\n  messagesFactoryWrapper,\r\n} from './mockStateFactories';\r\nimport { IMockChatInfo } from './interfaces/IMockChatInfo';\r\nimport { IMockMessage } from './interfaces/IMockMessage';\r\nimport { IUser } from '../../models/interfaces/IUser';\r\n\r\nexport class MockStateStorage {\r\n  private userStorage: IHashTable<IUser> = {};\r\n  private chatStorage: IHashTable<IMockChatInfo> = {};\r\n  private messageStorage: IHashTable<IMockMessage[]> = {};\r\n  private initialized = false;\r\n\r\n  private async init() {\r\n    const { chatNames, usernames, messages } = await import('./mockStateDictionary.json');\r\n    this.initializeStorage(chatNames, usernames, messages);\r\n    this.initialized = true;\r\n  }\r\n\r\n  private initializeStorage(chatNames: string[], usernames: string[], messages: string[]) {\r\n    this.userStorage = storageAssembler<IUser>(usernames.map(() => uuid()), userFactoryWrapper(usernames));\r\n    this.chatStorage = storageAssembler<IMockChatInfo>(chatNames.map(() => uuid()), chatInfoFactoryWrapper(chatNames));\r\n    this.messageStorage = storageAssembler<IMockMessage[]>(\r\n      Object.keys(this.chatStorage),\r\n      messagesFactoryWrapper(messages, Object.keys(this.userStorage)),\r\n    );\r\n  }\r\n\r\n  getUserById(id: string) {\r\n    return this.userStorage[id];\r\n  }\r\n\r\n  getChats() {\r\n    return this.chatStorage;\r\n  }\r\n\r\n  getMessages() {\r\n    return this.messageStorage;\r\n  }\r\n\r\n  getChatHistoryByChatId(id: string) {\r\n    return this.messageStorage[id];\r\n  }\r\n\r\n  checkIfInitialized() {\r\n    if (this.initialized) {\r\n      return Promise.resolve();\r\n    }\r\n    return this.init();\r\n  }\r\n}\r\n","/* eslint-disable no-useless-constructor */\r\n/* eslint-disable no-empty-function */\r\n\r\nimport { MockStateStorage } from './MockStateStorage';\r\nimport { IChatInfo } from '../../models/interfaces/IChatInfo';\r\nimport { IMockChatInfo } from './interfaces/IMockChatInfo';\r\nimport { IHashTable } from '../../models/interfaces/IHashTable';\r\nimport { IMockMessage } from './interfaces/IMockMessage';\r\nimport { ITextMessage } from '../../models/interfaces/IMessage';\r\n\r\nclass MockService {\r\n  constructor(private storage: MockStateStorage) { }\r\n\r\n  async getChatList(): Promise<IChatInfo[]> {\r\n    await this.storage.checkIfInitialized();\r\n    const chats = this.storage.getChats();\r\n    const messages = this.storage.getMessages();\r\n    const chatInfo: IChatInfo[] = this.mapToChatInfo(chats, messages);\r\n    return chatInfo;\r\n  }\r\n\r\n  async getChatHistoryByChatId(chatId: string): Promise<ITextMessage[]> {\r\n    await this.storage.checkIfInitialized();\r\n    const history = this.storage.getChatHistoryByChatId(chatId);\r\n    return this.mapToMessage(history);\r\n  }\r\n\r\n  private mapToMessage(history: IMockMessage[]) {\r\n    return history.map((m) => {\r\n      const { authorId, ...lastMessage } = m;\r\n      return { ...lastMessage, author: this.storage.getUserById(authorId) };\r\n    });\r\n  }\r\n\r\n  private mapToChatInfo(\r\n    chats: IHashTable<IMockChatInfo>,\r\n    messages: IHashTable<IMockMessage[]>,\r\n  ): IChatInfo[] {\r\n    return Object.keys(chats)\r\n      .map((chatId) => {\r\n        const chat = chats[chatId];\r\n        const chatMessages = messages[chat.guid];\r\n        const { authorId, ...lastMessage } = chatMessages[chatMessages.length - 1];\r\n        return {\r\n          ...chat,\r\n          lastMessage: {\r\n            ...lastMessage,\r\n            author: this.storage.getUserById(authorId),\r\n          },\r\n        };\r\n      });\r\n  }\r\n}\r\n\r\nexport const mockService = new MockService(new MockStateStorage());\r\n","const sortByDate = (a: number, b: number) => {\r\n  if (a > b) {\r\n    return -1;\r\n  }\r\n  if (a < b) {\r\n    return 1;\r\n  }\r\n  return 0;\r\n};\r\n\r\nconst sortHelper = {\r\n  sortByDate,\r\n};\r\n\r\nexport default sortHelper;\r\n","import { v4 as uuid } from 'uuid';\r\n\r\nimport { ITextMessage } from '../models/interfaces/IMessage';\r\nimport { MessageList } from '../models/types/MessageList';\r\nimport { MessageTypes } from '../models/enums/MessageTypes';\r\n\r\nimport dateHelper from './dateHelper';\r\n\r\nconst addServiceMessageToChatHistory = (messageList: ITextMessage[]): MessageList => {\r\n  const dateSet: Set<number> = new Set();\r\n  return messageList.reduce((acc: MessageList, m) => {\r\n    const timestamp = dateHelper.removeTimeFromTimestamp(m.timestamp);\r\n    if (!dateSet.has(timestamp)) {\r\n      dateSet.add(timestamp);\r\n      acc.push({\r\n        guid: uuid(),\r\n        timestamp,\r\n        type: MessageTypes.Service,\r\n      });\r\n    }\r\n    acc.push(m);\r\n    return acc;\r\n  }, []);\r\n};\r\n\r\nconst utils = {\r\n  addServiceMessageToChatHistory,\r\n};\r\n\r\nexport default utils;\r\n","import React, { Component } from 'react';\r\n\r\nimport { MainSidebar } from '../Sidebar/MainSidebar';\r\nimport { MainContent } from '../Content/MainContent';\r\n\r\nimport { IMainLayoutState } from './IMainLayoutState';\r\n\r\nimport { mockService } from '../../../helpers/MockState/MockService';\r\nimport sortHelper from '../../../helpers/sortHelper';\r\nimport utils from '../../../helpers/utils';\r\n\r\nimport './MainLayout.css';\r\n\r\nexport class MainLayout extends Component<{}, IMainLayoutState> {\r\n  constructor(props = {}) {\r\n    super(props);\r\n    this.state = {\r\n      selectedChat: '',\r\n      chatList: [],\r\n      chatHistory: {},\r\n    };\r\n  }\r\n\r\n  async componentDidMount() {\r\n    const chatList = await mockService.getChatList();\r\n    this.setState({\r\n      chatList,\r\n    });\r\n  }\r\n\r\n  private onChatSelected = (selectedChat: string) => {\r\n    this.setState(\r\n      { selectedChat },\r\n      () => this.loadChatHistory(),\r\n    );\r\n  }\r\n\r\n  private onChatClosed = () => {\r\n    this.setState({ selectedChat: '' });\r\n  }\r\n\r\n  private getMessageList() {\r\n    const { selectedChat, chatHistory: messages } = this.state;\r\n    const history = messages[selectedChat];\r\n    return utils.addServiceMessageToChatHistory(history || []);\r\n  }\r\n\r\n  private getSortedChatList() {\r\n    const { chatList } = this.state;\r\n    return chatList.sort((a, b) => {\r\n      return sortHelper.sortByDate(a.lastMessage.timestamp, b.lastMessage.timestamp);\r\n    });\r\n  }\r\n\r\n  private loadChatHistory() {\r\n    const { selectedChat, chatHistory: messages } = this.state;\r\n    const isHistoryExist = messages[selectedChat];\r\n    if (!isHistoryExist) {\r\n      mockService.getChatHistoryByChatId(selectedChat)\r\n        .then((chatHistory) => this.setState({\r\n          chatHistory: { ...messages, [selectedChat]: chatHistory },\r\n        }));\r\n    }\r\n  }\r\n\r\n  render() {\r\n    const { selectedChat } = this.state;\r\n    const chatList = this.getSortedChatList();\r\n    const messageList = this.getMessageList();\r\n    return (\r\n      <main className=\"layout\">\r\n        <MainSidebar\r\n          className={`${selectedChat ? 'hidden' : 'displayed'}`}\r\n          onChatSelected={this.onChatSelected}\r\n          selectedChat={selectedChat}\r\n          chatList={chatList}\r\n        />\r\n        <MainContent\r\n          className={`${selectedChat ? 'displayed' : 'hidden'}`}\r\n          onChatClosed={this.onChatClosed}\r\n          messageList={messageList}\r\n        />\r\n      </main>\r\n    );\r\n  }\r\n}\r\n","import React from 'react';\r\n\r\nimport { MainLayout } from './components/Main/Layout/MainLayout';\r\n\r\nimport './App.css';\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <MainLayout />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}